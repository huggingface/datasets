# الترميز الدفعي

إن الجمع بين فائدة [`Dataset.map`] ووضع الدفعات أمر قوي للغاية. فهو يسمح لك بزيادة سرعة المعالجة، والتحكم بحرية في حجم المجموعة الناتجة.

## الحاجة إلى السرعة

الهدف الأساسي من الترميز الدفعي هو تسريع المعالجة. غالبًا ما يكون العمل على دفعات من البيانات أسرع من العمل على أمثلة فردية. وبشكل طبيعي، يناسب الترميز الدفعي عملية التجزئة إلى رموز. على سبيل المثال، تعمل مكتبة 🤗 [Tokenizers](https://huggingface.co/docs/tokenizers/python/latest/) بشكل أسرع مع الدفعات لأنها توازي عملية التجزئة إلى رموز لجميع الأمثلة في الدفعة.

## حجم الإدخال != حجم الإخراج (Input size != output size)

يمكن الاستفادة من القدرة على التحكم في حجم المجموعة الناتجة في العديد من حالات الاستخدام المثيرة للاهتمام. في قسم كيفية [الرسم](#map)، هناك أمثلة على استخدام الترميز الدفعي للقيام بما يلي:

- تقسيم الجمل الطويلة إلى مقاطع أقصر.
- زيادة مجموعة من البيانات باستخدام رموز إضافية.

من المفيد فهم كيفية عمل ذلك، حتى تتمكن من ابتكار طرقك الخاصة لاستخدام الترميز الدفعي. في هذه المرحلة، قد تتساءل عن كيفية التحكم في حجم المجموعة الناتجة. الإجابة هي: **لا يلزم أن تعيد الدالة المرسومة إخراج دفعة بنفس الحجم**.

بمعنى آخر، يمكن أن يكون إدخال الدالة المرسومة دفعة بحجم `N` وتعيد دفعة بحجم `M`. يمكن أن يكون الإخراج `M` أكبر أو أقل من `N`. وهذا يعني أنه يمكنك دمج أمثلك، وتقسيمها، وحتى إضافة المزيد من الأمثلة!

ومع ذلك، تذكر أن جميع القيم في قاموس الإخراج يجب أن تحتوي على **نفس عدد العناصر** مثل الحقول الأخرى في قاموس الإخراج. وإلا، لن يكون من الممكن تحديد عدد الأمثلة في الإخراج الذي تعيده الدالة المرسومة. يمكن أن يختلف العدد بين الدفعات المتتالية التي تعالجها الدالة المرسومة. ولكن بالنسبة لدفعة واحدة، يجب أن يكون لجميع قيم قاموس الإخراج نفس الطول (أي عدد العناصر).

على سبيل المثال، بالنسبة لمجموعة بيانات مكونة من عمود واحد و3 صفوف، إذا استخدمت `map` لإرجاع عمود جديد يحتوي على ضعف عدد الصفوف، فستحصل على خطأ.

في هذه الحالة، ستحصل على عمود واحد يحتوي على 3 صفوف، وعمود آخر يحتوي على 6 صفوف. كما ترى، لن يكون الجدول صالحًا:

```py
>>> from datasets import Dataset
>>> dataset = Dataset.from_dict({"a": [0, 1, 2]})
>>> dataset.map(lambda batch: {"b": batch["a"] * 2}, batched=True)  # new column with 6 elements: [0, 1, 2, 0, 1, 2]
'ArrowInvalid: Column 1 named b expected length 3 but got length 6'
```

لجعله صالحًا، يجب عليك إسقاط أحد العمودين:

```py
>>> from datasets import Dataset
>>> dataset = Dataset.from_dict({"a": [0, 1, 2]})
>>> dataset_with_duplicates = dataset.map(lambda batch: {"b": batch["a"] * 2}, remove_columns=["a"], batched=True)
>>> len(dataset_with_duplicates)
6
```