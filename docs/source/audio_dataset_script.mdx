# Create an audio dataset

There are two methods for creating and sharing an audio dataset. This guide will show you how to:

* Create an audio dataset with `AudioFolder` and some metadata. This is a no-code solution for quickly creating an audio dataset.

* Create an audio dataset by writing a loading script. This method is a bit more involved, but you have greater flexibility over how a dataset is defined, downloaded, and generated.

<Tip>

You can control access to your dataset by requiring users to share their contact information first. Check out the [Gated datasets](https://huggingface.co/docs/hub/datasets-gated) guide for more information about how to enable this feature on the Hub.

</Tip>

## AudioFolder

The `AudioFolder` is a dataset builder designed to quickly load an audio dataset without requiring you to write any code. `AudioFolder` automatically infers the class labels of your dataset based on the directory name. Just store your dataset in a directory structure like:

```
folder/train/en_us/14223464699748513050.wav
folder/train/en_us/363601479976099198.wav
folder/train/en_us/9644097927007796370.wav

folder/train/fr_fr/14945328524472190788.wav
```

Then users can load your dataset by specifying `audiofolder` in load_dataset() and the directory in `data_dir`:

```py
>>> from datasets import load_dataset
>>> dataset = load_dataset("audiofolder", data_dir="/path/to/folder")
```

This is useful for audio classification, but for other audio tasks, you may need to include additional information about your dataset like transcription, speaker accent or speaker intent. This information can be added in a `metadata.jsonl` file in your data folder, which lets you quickly create datasets for different audio tasks like automatic speech recognition:

```
folder/train/metadata.jsonl
folder/train/first_audio_file.mp3
folder/train/second_audio_file.mp3
folder/train/third_audio_file.mp3
```

The `metadata.jsonl` file needs a `file_name` column to link an audio file to it's metadata:

```json
{"file_name": "first_audio_file.mp3", "transcription": "znowu się duch z ciałem zrośnie w młodocianej wstaniesz wiosnie i możesz skutkiem tych leków umierać wstawać wiek wieków dalej tam były przestrogi jak siekać głowę jak nogi"}
{"file_name": "second_audio_file.mp3", "transcription": "już u źwierzyńca podwojów król zasiada przy nim książęta i panowie rada a gdzie wzniosły krążył ganek rycerze obok kochanek król skinął palcem zaczęto igrzysko"}
{"file_name": "third_audio_file.mp3", "transcription": "pewnie kędyś w obłędzie ubite minęły szlaki zaczekajmy dzień jaki poślemy szukać wszędzie dziś jutro pewnie będzie posłali wszędzie sługi czekali dzień i drugi gdy nic nie doczekali z płaczem chcą jechać dali"}
```

## Loading script

Write a dataset loading script to share a dataset. It defines a dataset's splits and configurations, and handles downloading and generating a dataset. The script is located in the same folder or repository as the dataset.

```
my_dataset/
├── README.md
├── my_dataset.py
└── data/  # optional, may contain your audio files or TAR archives
```

This structure allows your dataset to be loaded in one line:

```py
>>> from datasets import load_dataset
>>> dataset = load_dataset("path/to/my_dataset")
```

This guide will show you how to create a dataset loading script for audio datasets, which is a bit different from <a class="underline decoration-green-400 decoration-2 font-semibold" href="./dataset_script">creating a loading script for text datasets</a>. You'll learn how to:

* Create a dataset builder class.
* Create dataset configurations.
* Add dataset metadata.
* Download and define the dataset splits.
* Generate the dataset.
* Generate the dataset metadata (optional).
* Upload the dataset to the Hub.

The best way to learn is to open up an existing audio dataset loading script, like [MInDS-14](https://huggingface.co/datasets/PolyAI/minds14), and follow along!

<Tip>

To help you get started, we created a loading script [template](https://github.com/huggingface/datasets/blob/main/templates/new_dataset_script.py) you can copy and use as a starting point!

</Tip>

### Create a dataset builder class

[`GeneratorBasedBuilder`] is the base class for datasets generated from a dictionary generator. Within this class, there are three methods to help create your dataset:

* `info` stores information about your dataset like its description, license, and features.
* `split_generators` downloads the dataset and defines its splits.
* `generate_examples` generates the audio files and other features like transcription or speaker intent for each split.

Start by creating your dataset class as a subclass of [`GeneratorBasedBuilder`] and add the three methods. Don't worry about filling in each of these methods yet, you'll develop those over the next few sections:

```py
class Minds14(datasets.GeneratorBasedBuilder):
    """MInDS-14 dataset"""

    def _info(self):

    def _split_generators(self, dl_manager):

    def _generate_examples(self, images, metadata_path):
```

#### Multiple configurations

In some cases, a dataset may have more than one configuration. For example, the MInDS-14 dataset has several configurations corresponding to different languages.

To create different configurations, use the [`BuilderConfig`] class to create a subclass for your dataset. Provide the links to download the audio files in `data_url`:

```py
class Minds14Config(datasets.BuilderConfig):
    """BuilderConfig for xtreme-s"""

    def __init__(
        self, name, description, homepage, data_url
    ):
        super(Minds14Config, self).__init__(
            name=self.name,
            version=datasets.Version("1.0.0", ""),
            description=self.description,
        )
        self.name = name
        self.description = description
        self.homepage = homepage
        self.data_url = data_url
```

Now you can define your configurations at the top of [`GeneratorBasedBuilder`]. For memory intensive data formats like audio datasets, it is often a good idea to set a lower `writer_batch_size`: 

```py
class Minds14(datasets.GeneratorBasedBuilder):

    DEFAULT_WRITER_BATCH_SIZE = 1000
    BUILDER_CONFIGS = [_build_config(name) for name in _ALL_CONFIGS + ["all"]]
```

You'll notice the author of this particular loading script defined the configuration names earlier in the script, and created a function to build each configuration. It doesn't really matter how you create the configuration objects, but each configuration should have a name, description, and where to download the data from.

```py
_ALL_CONFIGS = sorted([
    "cs-CZ", "de-DE", "en-AU", "en-GB", "en-US", "es-ES", "fr-FR", "it-IT", "ko-KR", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "zh-CN"
])

def _build_config(name):
    return Minds14Config(
        name=name,
        description=_DESCRIPTION,
        homepage=_HOMEPAGE_URL,
        data_url=_DATA_URL,
    )
```

Now if users want to load the `ko-KR` configuration, they can use the configuration name:

```py
>>> from datasets import load_dataset
>>> dataset = load_dataset("PolyAI/minds14", "ko-KR", split="train")
```

### Add dataset metadata

Adding information about your dataset is useful for users to learn more about it. This information is stored in the [`DatasetInfo`] class which is returned by the `info` method. Users can access this information by:

```py
>>> from datasets import load_dataset_builder
>>> ds_builder = load_dataset_builder("PolyAI/minds14")
>>> ds_builder.info
```

There is a lot of information you can specify about your dataset, but some important ones to include are:

1. `description` provides a concise description of the dataset.
2. `features` specify the dataset column types. Since you're creating an audio loading script, you'll need to include the [`Audio`] feature and specify the `sampling_rate` of the dataset.
3. `supervised_keys` specify the input feature and label.
4. `homepage` provides a link to the dataset homepage.
5. `citation` is a BibTeX citation of the dataset.

<Tip>

You'll notice a lot of the dataset information is defined earlier in the loading script which makes it easier to read. There are also other [`~Datasets.Features`] you can input, so be sure to check out the full list for more details.

</Tip>

```py
def _info(self):
    task_templates = None
    langs = _ALL_CONFIGS
    features = datasets.Features(
        {
            "path": datasets.Value("string"),
            "audio": datasets.Audio(sampling_rate=8_000),
            "transcription": datasets.Value("string"),
            "english_transcription": datasets.Value("string"),
            "intent_class": datasets.ClassLabel(
                names=[
                    "abroad",
                    "address",
                    "app_error",
                    "atm_limit",
                    "balance",
                    "business_loan",
                    "card_issues",
                    "cash_deposit",
                    "direct_debit",
                    "freeze",
                    "high_value_payment",
                    "joint_account",
                    "latest_transactions",
                    "pay_bill",
                ]
            ),
            "lang_id": datasets.ClassLabel(names=langs),
        }
    )

    return datasets.DatasetInfo(
    description=self.config.description + "\n" + _DESCRIPTION,
    features=features,
    supervised_keys=("audio", "transcription"),
    homepage=self.config.homepage,
    citation=_CITATION,
    task_templates=task_templates,
)
```

### Download and define the dataset splits

Now that you've added some information about your dataset, the next step is to download the dataset and generate the splits.

1. Use the [`DownloadManager.download_and_extract`] method to download and extract the URLs. This method accepts:

    * a name to a file inside a Hub dataset repository (in other words, the `data/` folder)
    * a URL to a file hosted somewhere else
    * a list or dictionary of file names or URLs

    For the `audio` and `text` data at these URLs, use the [`DownloadManager.extract`] method to extract the file paths.

2. After you've downloaded the dataset, use the [`SplitGenerator`] to organize the audio files and text transcriptions in each split. Name each split with a standard name like: `Split.TRAIN`, `Split.TEST`, and `SPLIT.Validation`. 

    In the `gen_kwargs` parameter, specify the file paths to the `audio` and `text` files to load. If necessary, you can use [`DownloadManager.iter_archive`] to iterate over audio files in TAR archives, which allows your dataset to be streamable. The `audio` and `text` file paths are actually passed onto the next step where you'll actually generate the dataset.

<Tip warning={true}>

To stream a TAR archive file, you need to use [`DownloadManager.iter_archive`]! The [`DownloadManager.download_and_extract`] function does not support TAR archives in streaming mode.

</Tip>

```py
def _split_generators(self, dl_manager):
    langs = (
        _ALL_CONFIGS
        if self.config.name == "all"
        else [self.config.name]
    )

    archive_path = dl_manager.download_and_extract(self.config.data_url)
    audio_path = dl_manager.extract(
        os.path.join(archive_path, "MInDS-14", "audio.zip")
    )
    text_path = dl_manager.extract(
        os.path.join(archive_path, "MInDS-14", "text.zip")
    )

    text_path = {l: os.path.join(text_path, f"{l}.csv") for l in langs}

    return [
        datasets.SplitGenerator(
            name=datasets.Split.TRAIN,
            gen_kwargs={
                "audio_path": audio_path,
                "text_paths": text_path,
            },
        )
    ]
```

### Generate the dataset

The last method in the [`GeneratorBasedBuilder`] class actually generates the audio and transcriptions in the dataset. It yields a dataset according to the stucture specified in `features` from the `info` method. As you can see, `generate_examples` accepts the `audio_path` and `text_paths` from the previous method as arguments.

<Tip warning={true}>

To stream a TAR archive file, it needs to be opened and read first. TAR files are accessed and yielded sequentially. This means you need to have the information in the TAR file in hand first so you can yield it with its corresponding audio file.

</Tip>

Now you can write a function for opening and loading examples from the dataset:

```py
def _generate_examples(self, audio_path, text_paths):
    key = 0
    for lang in text_paths.keys():
        text_path = text_paths[lang]
        with open(text_path, encoding="utf-8") as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=",", skipinitialspace=True)
            next(csv_reader)
            for row in csv_reader:
                file_path, transcription, english_transcription, intent_class = row

                file_path = os.path.join(audio_path, *file_path.split("/"))
                yield key, {
                    "path": file_path,
                    "audio": file_path,
                    "transcription": transcription,
                    "english_transcription": english_transcription,
                    "intent_class": intent_class.lower(),
                    "lang_id": _ALL_CONFIGS.index(lang),
                }
                key += 1
```

### Generate the dataset metadata (optional)

The dataset metadata you added earlier now needs to be generated and stored in a file called `datasets_infos.json`. In addition to information about a datasets features and description, this file also contains data file checksums to ensure integrity.

Run the following command to generate your dataset metadata in `dataset_infos.json` and make sure your new loading script works correctly:

```bash
datasets-cli test path/to/<your-dataset-loading-script> --save_infos --all_configs
```

If your loading script passed the test, you should now have a `dataset_infos.json` file in your dataset folder.

### Upload the dataset to the Hub

Once your script is ready, [create a dataset card](./dataset_card) and [upload it to the Hub](./share).

Congratulations, you can now load your dataset from the Hub! 🥳

```py
>>> from datasets import load_dataset
>>> load_dataset("<username>/my_dataset")
```