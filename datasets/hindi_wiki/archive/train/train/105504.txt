नियमित व्यंजक या रेग्युलर ऍक्सप्रैशन कम्प्यूटिंग में स्ट्रिंग्स की खोज या खोजो-और-बदलो के लिए संक्षिप्त, लचीला और सुविधाजनक तरीका है। उदाहरण के लिये कम खोजने पर यह कमल को भी खोजेगा और कमर को भी। रेग्युलर ऍक्सप्रैशन को regex या regexp के रूप में संक्षेपित किया जाता है। 
रेग्युलर ऍक्सप्रैशन का प्रयोग कई प्रोग्रामन भाषाओं में करना सम्भव है इसके प्रयोग से एक ही लाइन में बहुत बड़ी बात कही या लिखी जा सकती है जिससे प्रोग्राम छोटा और सुवाच्य हो जाता है। जो प्रोग्रामर नहीं हैं उनके लिये यह 'फाइण्ड ऐण्ड रिप्लेस' के रूप में इसका बहुत उपयोग है।
निम्नलिखित उदाहरण कुछ ऐसी विशेषताओं को स्पष्ट करते हैं, जिन्हें रेग्युलर ऍक्सप्रैशन में अभिव्यक्त किया जा सके: 
रेग्युलर ऍक्सप्रैशन इन उदाहरणों से भी अधिक जटिल हो सकते हैं:रेग्युलर ऍक्सप्रैशन के प्रयोग कई पाठ संपादकों द्वारा उपयोगिता एवं भाषाओँ की प्रोग्रामिंग में पैटर्न पर आधारित मूल पाठ की खोज और उसमें मनचाहे बदलाव के लिए किया गए हैं। उदाहरण के लिए, Perl, Ruby और Tcl सशक्त रेग्युलर ऍक्सप्रैशन इंजिन उनके वाक्य विन्यास में बना हुआ है। Unix वितरणों के द्वारा प्रदत्त अनेक उपयोगिताएं -- संपादक ed एवं फिल्टर grep—रेग्युलर ऍक्सप्रैशन की अवधारणा को लोकप्रिय बनाने में सर्वप्रथम थे।
वाक्य रचना के एक उदाहरण के रूप में, रेग्युलर ऍक्सप्रैशन \bex का प्रयोग "शब्द सीमाओं" के बाद आने वाले "ex " स्ट्रिंग के सभी उदाहरणों की खोज के लिए हो सकता है। अल्पज्ञों की शब्दावली में, \bex अपने से मिलता जुलता स्ट्रिंग "ex" को दो संभावित क्षेत्रों में खोज लेगा, शब्दों के आरंभ में और एक स्ट्रिंग में दो वर्णों के बीच में, जिसमें से एक तो शब्द वर्ण है और दूसरा शब्द वर्ण नहीं है। इस प्रकार, स्ट्रिंग में "Texts for experts", \bex "एक्सपर्ट्स" में तो "ex " के साथ मेल खाता है, लेकिन "Texts" में मेल नहीं खाता .
कई आधुनिक कम्प्यूटिंग प्रणालियां एक फाइल सिस्टम से फाइलनेम्स के साथ मेल खिलाने के लिए वाइल्डकार्ड वर्ण उपलब्ध कराती हैं। यह कई कमांड-लाइन शेल्स की आभ्यंतर क्षमता है, जिसे ग्लोबिंग के रूप में भी जाना जाता है। वाइल्डकार्ड आमतौर पर रेग्युलर ऍक्सप्रैशन से केवल विकल्पों को सीमित रूप में सूचित करने के मामले में भिन्न है।
रेग्युलर ऍक्सप्रैशन वाक्य विन्यास की उत्पत्ति में उपयोगी हैं जो प्रणालियों को उजागर करते हैं, जैसे कि डेटा सत्यापन और कई अन्य कार्यों के निष्पादन में.
रेग्युलर ऍक्सप्रैशन खोज इंजन के लिए उपयोगी होगा जैसे Google, Bing या Yahoo! Search में तो संपूर्ण डेटाबेस से होकर गुजरते हुए प्रोसेसिंग करना जटिलता और रिजेक्स की डिजाइन को देखते हुए अधिक कम्प्यूटर संसाधन खर्च करना होगा। हालांकि कई स्थितियों में सिस्टम प्रशासक रिजेक्स आधारित आंतरिक प्रश्नों को चला सकता है, अधिकतर सर्च इंजन लोगों को रिजेक्स की सहायता उपलब्ध नहीं कराते. एक उल्लेखनीय अपवाद गूगल कोड सर्च है।
रेग्युलर ऍक्सप्रैशन, जिसे प्रायः पैटर्न भी कहा जाता है, एक ऐसा सूचक है जो स्ट्रिंग्स के एक सेट के बारे में विस्तार से बतलाता है। उनका उपयोग आमतौर पर तत्वों की सूची बनाए बिना सेट के बारे में संक्षेप में बताने के लिए होता है। उदाहरण के लिए, 'सेट' जिसमें तीन स्ट्रिंग्स होते हैं "Handel ", "Händel " और "Haendel " को H ndel के पैटर्न के रूप में वर्णित किया जा सकता है . अधिकतर आकारवादों में अगर कोई रिजेक्स किसी खास सेट के साथ मेल खाता है तो यह जान लेना चाहिए कि ऐसे सूचकों की अनंत संख्या है। अधिकांश आकारवाद निम्नलिखित क्रियाओं के लिए रेग्युलर ऍक्सप्रैशन बनाती हैं।
|grey के साथ "gray " या "grey " मेल खाता है।
|grey और gry समरूप पैटर्न्स हैं, जो "gray " और "grey " दोनों ही सेट को वर्णित करते हैं।
उदाहरण के लिए, ab*c "ac ", "abc ", "abbc ", "abbbc " और इसी प्रकार से मेल खाता है। 
इन बनावटों को मनमाने ढंग से जटिल सूचकों के गठन के लिए एक साथ जोड़ दिया जा सकता है, ठीक उसी तरह जिस तरह कोई अंकगणितीय सूचकों का गठन संख्याओं एवं संक्रियाओं +, −, × और ÷ से कर सकता है। उदाहरण के लिए, Hndel एवं Hndel दोनों ही प्रामाणिक पैटर्न हैं, जो पिछले उदाहरण की ही तह समान स्ट्रिंग्स के साथ मेल खाता है, वह पिछला उदाहरण है Hndel.
रेग्युलर ऍक्सप्रैशन के लिए सटीक वाक्य-विन्यास उपकरणों और संदर्भ के साथ बदलते रहते हैं; अधिक विवरण "वाक्य-विन्यास" खंड में दिया गया है।
रेग्युलर ऍक्सप्रैशन की जड़ें ऑटोमेटा सिद्धांत एवं औपचारिक भाषा सिद्धांत में निहित हैं, दोनों ही सैद्धांतिक कंप्यूटर विज्ञान के अंग हैं। ये क्षेत्र प्रशिक्षण कंप्यूटेशन एवं औपचारिक भाषाओं के वर्णन एवं वर्गीकरण की पद्धतियों के मॉडल हैं। 1950 के दशक में, गणितज्ञ स्टीफेन कोल क्लीन ने अपने गणितीय संकेतन का प्रयोग करते हुए इन मॉडलों का सविस्तार वर्णन किया, जिसे रेगुलर सेट्स कहते हैं। SNOBOL की भाषा पैटर्न मिलान कराने का आरंभिक उपकरण था, लेकिन रेग्युलर ऍक्सप्रैशन के सदृश नहीं. केन थॉम्पसन ने टेक्स्ट फाइल्स में पैटर्न्स के मिलान कराने के माध्यम के रूप में क्लीन के संकेतन का उपयोग संपादक QED के गठन में किया। बाद में उन्होंने Unix संपादक ed में इस क्षमता को जोड़ा, जिसने अंततः रेग्युलर ऍक्सप्रैशन के उपयोग के लिए लोकप्रिय खोजी उपकरण ग्रेप का पता लगाया . समयांतराल से, रेग्युलर ऍक्सप्रैशन के थॉम्पसन के मौलिक रूपांतर में कई बदलाव आए हैं, जिनका व्यापक प्रयोग Unix और Unix जैसी ही प्रयोज्यता, expr, AWK, Emacs, vi और lex सहित हुआ है।
Perl और Tcl रेग्युलर ऍक्सप्रैशन हेनरी स्पेंसर लिखित रिजेक्स लाइब्रेरी से ली गई थीं, हालांकि Perl को स्पेंसर की लाइब्रेरी में अनेक नई विशेषताएं जोड़ने के लिए प्रसारित किया गया।फिलिप हेज़ेल ने PCRE को विकसित किया, जो पर्ल की रेग्युलर ऍक्सप्रैशन की कार्यशीलता की लगभग नकल करने की कोशिश करता है, एवं अनेक आधुनिक उपकरणों PHP और Apache HTTP Server के द्वारा प्रयोग में लाया जाता है। Perl 6 की डिज़ाइन की प्रचेष्टा का एक हिस्सा पर्ल के रेग्युलर ऍक्सप्रैशन के एकीकरण में सुधार तथा उनके कार्यक्षेत्र एवं क्षमताओं को बढ़ाना ताकि सूचकों की पदव्याख्या के व्याकरण को परिभाषित करने का मौका दिया जा सके. परिणामस्वरूप एक लघु भाषा Perl 6 नियम बनी, जिसका प्रयोग Perl 6 ग्रामर को परिभाषित करने और साथ ही साथ भाषा में प्रोग्रामर्स के लिए उपकरण मुहैया कराने के लिया होता है। ये नियम पर्ल 5.x रेग्युलर ऍक्सप्रैशन की विशेषताओं को कायम रखते हैं, लेकिन उप-नियमों के द्वारा पुनःप्रवाही सुंदर पद व्याख्या की BNF-शैली की परिभाषा को भी अनुमति प्रदान करते हैं।
दस्तावेज़ और डाटाबेस मॉडलिंग के लिए संरचित सूचना मानकों में रेग्युलर ऍक्सप्रैशन का प्रयोग 1960 के दशक में आरंभ हुआ और 1980 के दशक में फैल गया, जब ISO SGML उद्योग मानक समेकित हुए. भाषा मानकों में संरचना की सुस्पष्टता के केंद्र में रेग्युलर ऍक्सप्रैशन हैं। समूह वाक्य विन्यास में DTD तत्व का सरल उपयोग स्पष्ट है।
पैटर्न मिलान: इतिहास भी देखें
रेग्युलर ऍक्सप्रैशन को औपचारिक भाषा सिद्धांत के रूप में परिभाषित किया जा सकता है। रेग्युलर ऍक्सप्रैशन में स्थिरांक और ऑपरेटर्स होते हैं, जो स्ट्रिंग्स के सेट्स इन सेटों पर क्रियाशीलताओं को क्रमशः सूचित करते हैं। निम्नलिखित परिभाषा मानक है और औपचारिक भाषा सिद्धांत की अधिकांश पाठ्य पुस्तकों में पायी जाती है. एक सीमाबद्ध वर्णमाला Σ को देखते हुए निम्नलिखित स्थिरांकों की परिभाषा दी गई है:
निम्नलिखित संक्रियाएं परिभाषित हैं: 
| α in R and β in S } को संकेतित करता है। उदाहरण के लिए {"ab", "c"}{"d", "ef"} = {"abd", "abef", "cd", "cef"}.
| S जो R और S के गठबंधन को संकेतित करता है। उदाहरण के लिए {"ab", "c"}|{"ab", "d", "ef"} = {"ab", "c", "d", "ef"}.
कोष्ठकों से बचने के लिए यह मान लिया गया है कि क्लीन तारा को ही सर्वोच्च प्राथमिकता प्राप्त है और इसके बाद संयोजन और तब जाकर सेट गठबंधन को. अगर कोई संशय नहीं है तो कोष्ठकों का लोप हो सकता है। उदाहरण के लिए, c को abc और a|) को a|bc* जैसा भी लिखा जा सकता है। कई पाठ्य पुस्तकों में लंबरूप बार के बदले संयोजन के लिए ∪, +, या ∨ चिह्नों का प्रयोग मिलता है।
उदाहरण: 
|b* {ε, {0}a, b, bb, bbb, ...} को संकेतित करता है।
|b)* खाली स्ट्रिंग: {ε, {0}a, b, aa, ab, ba, bb, aaa, ...} समेत a और b के अलावा बिना प्रतीक चिह्नों के सभी स्ट्रिंग के सेट को संकेतित करता है।
|ε) a से आरंभ कर स्ट्रिंग्स के सेट को, तब जीरो अथवा अधिक b s और अंत में विकल्प के साथ a c : {{0}a, ac, ab, abc, abb, abbc, ...} को संकेतित करता है।
रेग्युलर ऍक्सप्रैशन की औपचारिक परिभाषा जानबूझकर किफायती है और अनावश्यक परिमाणक ? से बचने के लिए तथा +, जिसे : a+ = aa* और a?= के रूप में व्यक्त किया जा सकता है। कभी-कभी पूरक ऑपरेटर को जोड़ा जाता है; Rc Σ* पर सभी स्ट्रिंग्स के सेट को जो R c में नहीं हैं, संकेतित करते हैं। नियमतः पूरक ऑपरेटर अनावश्यक है, जैसा कि दूसरे ऑपरेटरों का उपयोग कर इसे सीमित किया जा सकता है। हालांकि, ऐसे निरूपण कम्प्यूटिंग प्रक्रिया जटिल है और इसके परिणाम को ऐसे आकार के सूचकों की आवश्यकता पड़ सकती है जो घातांकी रूप से दोगुने बड़े हैं.
इस अर्थ में रेग्युलर ऍक्सप्रैशन सुव्यवस्थित भाषा को सूचित कर सकते हैं, ठीक-ठीक भाषा की ऐसी श्रेणी जो नियमात्मक परिमित ऑटोमेटा के द्वारा स्वीकृत है। हालांकि फिर भी सुसंहति में एक उल्लेखनीय अंतर है। सुव्यवस्थित भाषाओँ की कुछ श्रेणियों को नियमात्मक परिमित ऑटोमेटा द्वारा वर्णित किया जा सकता है, जिसका आकार घातांकी रूप से सबसे छोटे रेग्युलर ऍक्सप्रैशन के समकक्ष बढ़ जाता है। भाषाएं ही यहां मानक उदाहरण हैं। Lk वर्ण {{0}a,b } पर जिसका अंतिम अक्षर k a की बराबरी अपने सभी स्ट्रिंग्स सहित करता है। एक ओर, L 4 को वर्णित करने वाले रेग्युलर ऍक्सप्रैशन    ∗  a   {\displaystyle ^{*}a} दिया हुआ है। इस पैटर्न को Lk में सामान्यीकरण सूचक देता है
दूसरी ओर, यह विदित है कि Lk भाषा को स्वीकार करता हुआ नियातात्मक परिमित ऑटोमेटन के पास कई स्थितियों में कम से कम 2k के होना जरूरी है। भाग्यवश, रेग्युलर ऍक्सप्रैशन से अधिक आम अनियतात्मक परिमित ऑटोमेटा तक सरल मानचित्रण है, जो अचानक इतना बड़ा विस्फोटक आकार ग्रहण नहीं कर लेता; यही कारण है कि NFAs को अक्सर सुव्यवस्थित भाषाओँ के वैकल्पिक निरूपण के रूप में इस्तेमाल किया जाता है। NFAs चोम्स्की अनुक्रम के टाइप-3 ग्रामर्स के सरल परिवर्तन हैं.
अंत में, यह ध्यान देने योग्य बात है कि वास्तव जगत में अनेक रेग्युलर ऍक्सप्रैशन इंजिन ऐसी विशेषताओं को लागू करते हैं, जिसे रेग्युलर ऍक्सप्रैशन के द्वारा औपचारिक भाषा सिद्धांत के अर्थ में वर्णित नहीं किया जा सकता; इस विषय पर अधिकाधिक जानकारी के लिए नीचे देखें.
जैसा कि उदाहरणों को देखने से पता चलता है, विभिन्न रेग्युलर ऍक्सप्रैशन उसी भाषा को अभिव्यक्त कर सकते हैं: रीतिवाद अनावश्यक है।
कलनविधि में लेखन संभव है जो दिए गए रेग्युलर ऍक्सप्रैशन के मध्य यह निर्णय करने के लिए कि उल्लिखित भाषाएं अनिवार्य रूप से एक समान हैं कि नहीं. यह प्रत्येक अभिव्यक्ति को न्यूनतम नियतात्मक परिमित स्थिति मशीन की हद तक कम कर देता है और निर्धारित करता है कि क्या वे समाकृतिक समकक्ष हैं या नहीं.
इस अनावश्यकता को किस हद तक निकाल दिया जा सकता है? क्या हम रेग्युलर ऍक्सप्रैशन का एक रोचक सबसेट खोज सकते हैं जो पूरी तरह सूचक हो? क्लीन तारा और सेट का गठबंधन स्पष्टतः आवश्यक है, लेकिन शायद हम उनके प्रयोग पर रोक लगा सकते हैं। यह आश्चर्यजनक रूप से कठिन समस्या में बदल सकता है। रेग्युलर ऍक्सप्रैशन इतने सरल हैं कि उन्हें किसी भी रूप में पुनः सुव्यवस्थित ढंग से लिखने की कोई प्रणाली है ही नहीं. अतीत में स्वतः प्रमाणन के अभाव में स्टार हाइट की समस्या खड़ी हो गई। हाल ही में, डेक्सटर कोज़ेन में रेग्युलर ऍक्सप्रैशन को क्लीन के बीजगणित के साथ स्वतः प्रमाणित कर दिया.
पारंपरिक Unix रेग्युलर ऍक्सप्रैशन वाक्य-विन्यास ने आम परिपाटी का अनुसरण नहीं किया, लेकिन एक उपकरण से दूसरे उपकरण में अक्सर अंतर रहता था। IEEE POSIX बेसिक रेग्युलर ऍक्सप्रैशन मानक खासकर उल्टी अनुकूलता के लिए परंपरागत वाक्य-विन्यास के साथ इसे डिज़ाइन किया गया, किंतु इसने एक सामान्य मानक उपलब्ध कराया जिसे कई Unix रेग्युलर ऍक्सप्रैशन उपकरणों के व्यतिक्रम वाले वाक्य-विन्यास के रूप में अपना लिया गया है, हालांकि इसमें अब भी अक्सर कुछ विविधताएं अथवा अतिरिक्त विशेषताएं दिखाई देती हैं। ऐसे अनेक उपकरण हैं जो कमांड लाइन विषयों के साथ ERE वाक्य-विन्यास को सहारा देते हैं।
BRE वाक्य-विन्यास में, अधिकांश अक्षरों को शाब्दिक अर्थ में लिया जाता है -- वे आपस में एक दूसरे से मेल खाते हैं . नीचे सूचीबद्ध अपवादों को अक्षरों से परे या अनुक्रमों से अलग कहा जाता है।
उदाहरण: 
अक्षरों से परे का अर्थ बैकस्लैश से बचकर कुछ अक्षरों के लिए POSIX विस्तृत रेग्युलर ऍक्सप्रैशन के वाक्य-विन्यास में विपरीत है। इस वाक्य-विन्यास में ही, एक बैकस्लैश के कारण मेटा कैरेक्टर को शाब्दिक अक्षरों के रूप में माना जाता है। अतः उदाहरण के लिए, \ अब है और \{ \} अब { }. साथ ही साथ, पिछले संदर्भों के लिए \n को हटा लिया गया है और निम्नलिखित अक्षरों से परे को शामिल किया गया हैं: 
उदाहरण: 
|dog "cat " या "dog " के साथ मेल खाता है।
POSIX विस्तारित रेग्युलर ऍक्सप्रैशन का प्रयोग अक्सर आधुनिक Unix प्रयोज्यता के साथ कमांड लाइन फ्लैग -E को शामिल कर किया जा सकता है।
चूंकि अक्षरों की अनेक वर्गीकृत श्रेणियां चुने हुए स्थानीय सेटिंग, POSIX मानक अक्षरों की कुछ श्रेणियों अथवा वर्गों को निम्न तालिका में दिखाया गया है:
POSIX अक्षरों की श्रेणियों का प्रयोग केवल कोष्ठक सूचकों के अंदर ही हो सकता है। उदाहरण के लिए, ab] उच्चवर्ग के बड़े अक्षरों एवं छोटे अक्षरों "a " और "b " के साथ ही मेल खाता है।
Perl के रेग्युलर ऍक्सप्रैशन में, के साथ मेल खाता है और के साथ गठबंधन करता है। एक अतिरिक्त गैर-POSIX श्रेणी को कुछ उपकरणों के द्वारा समझा गया है वह है, जिसे आमतौर पर प्लस रेखांकन underscore के द्वारा परिभाषित किया गया है। यह इस तथ्य को उद्भासित करता है कि कई प्रोग्रामिंग भाषाओँ में ये ही वे अक्षर हैं जिनका प्रयोग पहचान चिह्न के रूप में किया जा सकता है। संपादक Vim आगे वर्ड और वर्ड-हेड श्रेणी के बीच अंतर स्पष्ट करते हुए पहचान बताते हैं . चूंकि कई प्रोग्रामिंग भाषाओँ में जो अक्षर पहचान चिह्न के रूप में आरंभ कर सकते हैं वे उनके समान नहीं हैं, जो अन्य स्थिति में उपस्थित हो सकते हैं।
यह द्रष्टव्य है कि POSIX रेग्युलर ऍक्सप्रैशन मानकों कॉल कैरेक्टर क्लासेस दूसरे रेग्युलर ऍक्सप्रैशन के रंग में, जो उन्हें सहयोग प्रदान करते हुए उन्हें साधारणतया POSIX कैरेक्टर क्लासेस के रूप में संदर्भित किया जाता है। अधिकांश अन्य रेग्युलर ऍक्सप्रैशन फ्लेवर्स के साथ कैरेक्टर क्लासेस पद-बंध का प्रयोग POSIX निर्धारित कोष्ठक सूचकों का वर्णन करने के लिए किया जाता है।
POSIX बेसिक और विस्तारित रेग्युलर ऍक्सप्रैशन मानकों की तुलना में Perl के पास अधिक सुसंगत और समृद्ध वाक्य-विन्यास है। इसकी निरंतरता का एक उदाहरण है कि \ हमेशा गैर-वर्णान्कित अक्षरों से अलग भागता है। क्रियाशीलता का अन्य उदाहरण Perl के साथ तो संभव है, पर POSIX के साथ नहीं - अनुवर्ती रेग्युलर ऍक्सप्रैशन सुस्त परिमाणन की अवधारणा है .
व्यापक रूप से अपनी सूचक क्षमता के कारण कई अन्य प्रयोज्यता और प्रोग्रामिंग की भाषाओँ ने वाक्य-विन्यास को Perl की ही तरह अपना लिया है -- उदाहरण के लिए, Java, JavaScript, PCRE, Python, Ruby, Microsoft's .NET Framework और W3C's XML Schema सभी रेग्युलर ऍक्सप्रैशन वाक्य-विन्यास का प्रयोग Perl की ही तरह करते हैं। कुछ भाषाएं एवं उपकरण जैसे कि Boost और PHP बहु रेग्युलर ऍक्सप्रैशन फ्लेवर को सहयोग प्रदान करते हैं। Perl व्युत्पन्न रेग्युलर ऍक्सप्रैशन के कार्यान्वयन में एकरूपता नहीं है और कुछ केवल Perl की विशेषताओं के सबसेट को ही कार्यान्वित करते हैं। Perl 5.10 की प्रक्रिया अपनी पूर्णता और विस्तार के साथ Perl निगमित वाक्य-विन्यास के विस्तार तक पहुंच गई है - मूलतः Python, PCRE, .NET Framework और Java से.
सरल रेग्युलर ऍक्सप्रैशन ऐसा वाक्य-विन्यास है, जिनका प्रयोग कंप्यूटर ऍप्लिकेशन प्रोग्राम के ऐतिहासिक संस्करणों में किया जा सकता है एवं अपने अंतर्गत कुछ अनुप्रयोगों के द्वारा सहयोग भी पा सकता है। पिछली अनुरूपता प्रदान करने के उद्देश्य से इसे अनुचित समझा गया है।
रेग्युलर ऍक्सप्रैशन में मानक परिमापक लालची हैं अर्थात् वे जितना मेल खा सकते हैं अधिक से अधिक उतनी बार मेल खाते हैं, बाकी को रिजेक्स के साथ कोई नया मेल खाने के लिए छोड़ देते हैं। उदाहरण के लिए,regexes के लिए कोई नया जो किसी एक आइटम के बीच प्रथम दृष्टान्त खोजना चाहता है, इस उदाहरण में प्रतीक चिह्नों के बीच पा सकता है।
एक और व्हेल एक्स्प्लोज़न, को घटित हुआ।
... जो, पैटर्न के साथ अथवा इसी के समान आना चाहेगा. हालांकि यह पैटर्न वास्तव में ", " के बदले "" में वापस जाना चाहेगा, जो अपेक्षित था, क्योंकि * परिमाणन जो लालची है -- अतः यह यथासंभव अधिक से अधिक अक्षरों का उपभोग इनपुट से कर लेना चाहेगा, एवं "January 26>, " के पास "January 26" की तुलना में अधिक अक्षर होंगे.
हालांकि इस समस्या को कई तरीकों से टाला जा सकता है, आधुनिक रेग्युलर ऍक्सप्रैशन उपकरण एक परिमाणक को सुस्त के रूप में वैशिष्ट्य पाने की अनुमति देते हैं परिमाणक के बाद एक प्रश्नचिह्न लगाकर किया जाता है, अथवा संशोधक का प्रयोग कर जो परिमाणक के लालच को उलट देता है . सुस्त परिमाणक का प्रयोग कर सूचक सबसे पहले कम से कम मेल खाने की कोशिश करते हैं। हालांकि पूर्ववर्ती उदाहरण में सुस्त मेल का प्रयोग कई मेलों के परिणामों में से किसी एक का चुनाव करने के लिए किया जाता है, कुछ मामलों में इसका प्रयोग बेहतर निष्पादन के लिए भी किया जा सकता है, जब लालची मिलान को अधिक पीछे हटने की जरूरत पड़ेगी.
अव्यवस्थित भाषाओं के लिए पैटर्न आधुनिक रेग्युलर ऍक्सप्रैशन संग्रहों से प्राप्त कई विशेषताएं सूचक क्षमता प्रदान करती है जो सुव्यवस्थित भाषाओं से भी अधिक हो जाती है। उदाहरण के लिए, कई कार्यान्वयन उप सूचकों के समूहीकरण की अनुमति प्रदान करते हैं और उसी सूचक में मेल कराने की कीमत याद दिलाते हैं। इसका अर्थ यह है कि एक पैटर्न दुहराए गए शब्दों की लड़ियों से मेल खा सकता है, जैसे कि "पापा " अथवा "WikiWiki ", जिसे औपचारिक भाषा सिद्धांत में squares कहते हैं। इन लड़ियों के लिए पैटर्न है \1.
हालांकि, squares की भाषा सुव्यवस्थित नहीं है। न ही यह विषय से मुक्त है। बैक रेफरेन्सेस की असीमित संख्याओं पैटर्न के साथ मेल खाता, जैसे कि असीमित संख्या में आधुनिक उपकरण द्वारा समर्थित, एन पी-सम्पूर्ण है .
हालांकि, कई उपकरण, लाइब्रेरीज़ और इंजन जो ऐसी संरचनाएं उपलब्ध कराते हैं, अब भी रेग्युलर ऍक्सप्रैशन शब्दावली का प्रयोग अपने पैटर्नस के लिए करते हैं। इसने रेग्युलर ऍक्सप्रैशन शब्दावली का नामकरण किया है, जिसके औपचारिक भाषा सिद्धांत तथा पैटर्न के कई भिन्न अर्थ हैं। इस कारण, कुछ लोग regex या केवल पैटर्न शब्दावली का प्रयोग परवर्ती की व्याख्या में करते हैं। पर्ल प्रोग्रामिंग भाषा के लेखक, लैरी वॉल एक निबंध में पर्ल 6 के डिजाइन के बारे में लिखते हैं:
कम से कम तीन अलग-अलग कलां विधियां कलनविधि हैं, जो निर्धारित करती हैं कि एक दिया गया रेग्युलर ऍक्सप्रैशन किस प्रकार एक स्ट्रिंग के साथ मेल खता है।
सबसे पुराने और सबसे तेज परिणाम पर निर्भर दो औपचारिक भाषा सिद्धांत जो प्रत्येक गैरनियतात्मक परिमित स्थिति यंत्र को नियतात्मक परिमित स्थिति मशीन में रूपांतरित करना स्वीकार करता है। DFA का स्पष्ट रूप से निर्माण किया जा सकता है और तब इसके परिणामस्वरूप इनपुट पर एक बार में एक प्रतीक चिन्ह पर परिचालित होता है। एक रेग्युलर ऍक्सप्रैशन के आकार के लिए DFA का निर्माण "O" की कीमत पर करने पर समय और स्मृति आ जाती है, लेकिन यह n आकार के string पर ही O समय में चल सकता है। एक वैकल्पिक प्रयास NFA को सीधे अनुकरण करना है, मांग करने पर अनिवार्य रूप से प्रत्येक DFA स्थिति का निर्माण और तब अगले कदम पर संभवतः caching के साथ इसे बाहर निकाल देना. यह DFA को अंतर्निहित रखता है और निर्माण की घातांक लागत से बचा जा सकता है, लेकिन चलन लागत O तक बढ़ जाती है। इस स्पष्ट पदक्षेप को DFA कलनविधि कहते हैं और अंतर्निहित पदक्षेप को NFA कलनविधि. जैसे कि एक समान DFA को क्रियान्वित करने में दोनों को भिन्न तरीकों से देखा जा सकता है, उन्हें भी बिना भेद-भाव के अक्सर कलनविधि कहते हैं। ये कलन विधियां तेज़ हैं लेकिन समूहीकृत उपसूचकों को लौटाने के लिए उनका प्रयोग सुस्त परिमाणन एवं इसी प्रकार की विशेषताएं पेचीदा हैं।
तीसरी कलनविधि बैक ट्रैक के द्वारा पैटर्न के साथ इनपुट स्ट्रिंग के मिलान के लिए है। इस कलनविधि को आमतौर पर NFA कहा जाता है, लेकिन यह शब्दावली अस्पष्ट है। इसका चलन समय घातांकी हो सकता है, जिसका सरल कार्यान्वयन यह उजागर करता है कि जब सूचकों के खिलाफ मिलान जैसे कि *b जिसमे प्रत्यावर्तन और असीमित परिमाणन दोनों ही हैं। कलनविधि पर ज़ोर डालते हैं कि स्थानापन्न मामलों की बढती हुई घातांकी संख्या पर विचार करें. अधिक जटिल कार्यान्वयन अक्सर चिह्नित और गतिशील करते हैं या साधारण मामलों को रद्द कर देती हैं, जब उनका चलन मंद हो जाता है।
हालांकि बैक ट्रैकिंग कार्यान्वयन सबसे खराब स्थिति में एक घातांकी गारंटी देते हैं, वे बहुत अधिक लचीलापन और सूचक शक्ति प्रदान करते हैं। उदाहरण के लिए, किसी भी कार्यान्वयन जो बैकरेफरेन्सेस के प्रयोग की अनुमति देता है या पर्ल द्वारा लागू किये गए विभिन्न एक्सटेंशनस को कार्यान्वित करता है, उसे बैक ट्रैकिंग कार्यान्वयन का अवश्य प्रयोग करना चाहिए।
कुछ कार्यान्वयन सबसे पहले तेज़ DFA को चलाकर दो सबसे अच्छी कलन विधियां उपलब्ध कराते हैं, यह जानने के लिए कि रेग्युलर ऍक्सप्रैशन स्ट्रिंग के साथ थोडा भी मेल खाते हैं या नहीं और केवल इसी स्थिति में संभवतः मंद बैक ट्रैकिंग मिलान होता है।
रेग्युलर ऍक्सप्रैशन का आरंभिक प्रयोग ASCII अक्षरों के साथ हुआ। कई रेग्युलर ऍक्सप्रैशन इंजन अब संपूर्ण यूनिकोड के साथ भी काम कर सकते हैं। अधिकांश मामलों में इसमें कोई अंतर नहीं दिखता कि अक्षरों का सेट क्या है, लेकिन कुछ मामलों में फर्क पड़ता है जब रेग्युलर ऍक्सप्रैशन को यूनिकोड पर कार्य करना पड़ता है।
यह स्टेटमेन्ट यदि Á के बाद हल् आता है और उसके बाद देवनागरी का कोई ब्यंजन आता है तो उसे बदलकर पहले हल्, फिर देवनागरी व्यंजन और अन्त में Á रख देता है। यहाँ $2$3$1 का यही अर्थ है।
